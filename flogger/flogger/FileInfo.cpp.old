#include "pch.h"
#include "FileInfo.h"

#include <fstream>
#include <sstream>
#include <chrono>
#include <iomanip>
#include <cerrno>

using namespace std::literals;
namespace fs = std::filesystem;

namespace flogger {

	FileInfo::FileInfo(fs::path path) noexcept
		: m_path(std::move(path))
	{
	}

	const fs::path& FileInfo::path() const noexcept {
		return m_path;
	}

	bool FileInfo::exists() const noexcept {
		std::error_code ec;
		return fs::exists(m_path, ec);
	}

	bool FileInfo::isWritable() const noexcept {
		// Try to open for append (non-destructive) to verify writeability.
		// If the file doesn't exist, try to create the parent directory and then open.
		std::error_code ec;

		fs::path parent = m_path.parent_path();
		if (!parent.empty() && !fs::exists(parent, ec)) {
			// If we can't create parent directories, the file won't be writable.
			if (!fs::create_directories(parent, ec)) {
				if (ec) {
					const_cast<FileInfo*>(this)->logError("Failed to create parent directories for writeability check: "s + ec.message(), static_cast<int>(ec.value()));
					return false;
				}
			}
		}

		std::ofstream test(m_path, std::ios::app | std::ios::binary);
		bool ok = test.is_open();
		test.close();
		if (!ok) {
			// provide a helpful message for later inspection
			const_cast<FileInfo*>(this)->logError("Unable to open file for appending (isWritable check).", static_cast<int>(errno));
		}
		return ok;
	}

	void FileInfo::logException(const std::exception& ex, int code) const noexcept {
		logError(std::string("Exception: ") + ex.what(), code);
	}

	void FileInfo::logError(std::string_view message, int code) const noexcept {
		std::ostringstream ss;
		ss << "[" << currentTimestamp() << "] ";
		if (code != 0) ss << "(code " << code << ") ";
		ss << message;
		try {
			std::lock_guard<std::mutex> lock(m_errorsMutex);
			m_errors.emplace_back(ss.str());
		} catch (...) {
			std::cerr << "Unknown exception caught.\n";
		}
	}

	std::vector<std::string> FileInfo::getErrors() const noexcept {
		std::lock_guard<std::mutex> lock(m_errorsMutex);
		return m_errors;
	}

	void FileInfo::clearErrors() noexcept {
		std::lock_guard<std::mutex> lock(m_errorsMutex);
		m_errors.clear();
	}

	std::error_code FileInfo::write(const std::string& data, bool overwrite) noexcept {
		try {
			// Ensure parent directory exists
			std::error_code ec;
			fs::path parent = m_path.parent_path();
			if (!parent.empty() && !fs::exists(parent, ec)) {
				if (!fs::create_directories(parent, ec)) {
					if (ec) {
						logError("Failed to create parent directories before write: "s + ec.message(), static_cast<int>(ec.value()));
						return ec;
					}
				}
			}

			std::ofstream ofs;
			std::ios_base::openmode mode = std::ios::binary;
			mode |= (overwrite ? std::ios::trunc : std::ios::app);

			ofs.open(m_path, mode);
			if (!ofs.is_open()) {
				std::error_code openEc(errno, std::generic_category());
				logError("Failed opening file for write.", static_cast<int>(openEc.value()));
				return openEc;
			}

			ofs << data;
			if (!ofs.good()) {
				std::error_code writeEc(errno, std::generic_category());
				logError("I/O error while writing to file.", static_cast<int>(writeEc.value()));
				return writeEc;
			}
		}
		catch (const std::exception& ex) {
			logException(ex, -1);
			return std::make_error_code(std::errc::io_error);
		}
		catch (...) {
			logError("Unknown non-std exception during write.", -2);
			return std::make_error_code(std::errc::io_error);
		}

		return std::error_code{}; // success
	}

	std::string FileInfo::currentTimestamp() noexcept {
		try {
			auto now = std::chrono::system_clock::now();
			auto t = std::chrono::system_clock::to_time_t(now);
			std::tm tm{};
#if defined(_WIN32)
			localtime_s(&tm, &t);
#else
			localtime_r(&t, &tm);
#endif
			std::ostringstream ss;
			ss << std::put_time(&tm, "%Y-%m-%d %H:%M:%S");
			return ss.str();
		}
		catch (...) {
			return "<timestamp error>"s;
		}
	}

	std::string FileInfo::formatLoggedMessage(std::string_view base, int code) const noexcept {
		std::ostringstream ss;
		ss << "[" << currentTimestamp() << "] ";
		if (code != 0) ss << "(code " << code << ") ";
		ss << base;
		return ss.str();
	}

	// Example: static function needing to lock m_errorsMutex
	static void StaticFunction(FileInfo& instance) {
		// Directly access the protected member m_errorsMutex since this function is not a member or friend.
		// Change to use the public/protected interface or make this function a friend of FileInfo.

		// Option 1: Make StaticFunction a friend in FileInfo.h:
		// friend void StaticFunction(FileInfo&);

		// Option 2: Move StaticFunction inside FileInfo as a static member function:
		// static void StaticFunction(FileInfo& instance) { ... }

		// Option 3: If you must keep it as a free/static function, access m_errorsMutex directly (make it public),
		// but this is not recommended for encapsulation.

		// Best fix: Make StaticFunction a friend in FileInfo.h:
		// Add this line inside class FileInfo:
		// friend void StaticFunction(FileInfo&);

		std::lock_guard<std::mutex> lock(instance.m_errorsMutex);
		// ... access instance.m_errors ...
	}

} // namespace flogger